## Теоретическая часть, ЧАВО

**Замыкания** — самый распространенный вопрос на JS интервью прошлого десятилетия. По задумке должен показывать понимание кандидатом базовых принципов языка и основ работы компилятора, в реальности показывает какие учебники были на курсах у кандидата и в каком году он их заканчивал а также служит индикатором лени автора списка вопросов. Вариантов ответов много, понимания толково не даёт ни один. Но стоит один раз столкнуться с ситуацией где выводимая в маркапе на самом видном месте переменная принимает магически обусловленное и извращенно нелогичное постоянное значение - и сразу все понимаешь в процессе хотфикса этого милого бага на проде, особенно если это не твой код изначально но ты последний уходил из офиса, увлекшись интересной таской и был замечен PM в процессе долгожданного и заслуженного прощания с родным опенспейсом на тщательно накопленное и от того драгоценное время для продуманного сильно зарнее отпуска. Один такой кейс - и замыкания, JS нюансы, компиляторы, области видимости, среда выполнения - все это становится понятным и родным. "вот так и началась моя затяжная и полная милых сюрпризов интимная жизнь с JS")

**Ивентлуп** — самый распространенный вопрос нынешнего десятилетия. "И async съесть и awaitом не подавиться". Способ костыляции асинхронности в условиях однопоточности. Что хотели и что по итогу — смотри выше. Парадоксально иллюстративный пример усложнения простой и абсолютно прикладной концепции, описывающей  реализацию интересного и необычного паттерна, который изначально не предусмотрен ни в языке, ни в компиляторе ни в среде выполнения. Причина по сути сводилась к  "ну оооочень нужно" и "теперь не костыль". Понять гораздо глубже и адекватней можно поработав на реальном проекте с async-await, Promise, Observable, BehaviorSubject конструкциями - один простенький CRUD на Express + Angular 6+ и все понятно с тем как и через что работает асинхронность в одном потоке. А еще есть Reactor Pattern с его I/O нюансами - вот это в виде исключения реально стоит изучить внимательно для общего и частного понимания что есть JS на backend вместе с V8 VM - оффициальная документация написана для того чтобы вы её поняли, осознали и усвоили на интуитивно-подкожном спинномозговом уровне, а не для псевдоразумного дискурса, в отличии от большинства здесь упомянутых терминов и идей - что в нынешнее время редкость и стоит ценить.

**Паттерны** — считаются обязательными для backend интервью и с непрозрачно обусловленной периодичностью входят в моду на frontend поле. Набор очевидных решений для абстрактных задач. Ответ показывает уровень (неожиданно) шаблонности мышления у основных участников интервью и в силу повышенной холиварности отдельных пунктов — уровень адекватности их же. Достаточно сказать, что отрицательный вердикт по данному вопросу может вызвать выбор самого нормально объясняемого в силу ошеломляющей простоты и очевидности паттерна Синглтон — что переводится как «одиночка» - и неумолимая логика тянет в сторону предположения о том, что это слово болезненно отдается в  груди, паховой области и мозолистых ладонях типичного любителя паттернов. В отдельных случаях может продемонстрировать способность кандидата запоминать большие объемы мутного по содержанию и перегруженного по терминологии текста, написанного по принципу «непонятно о понятном или сложно о простом». Впрочем этой цели в той или иной мере посвящены все отмечаемые как «правильные» ответы на вопросы в типичном JS интервью. 

**Принципы ООП** — тоже пришло из ленивых backend опросников вместе с эрой TypeScript, ES6+ и расширения области применения JS с веббраузера на «везде». Уровень холиварности и субъективности восприятия тут похлеще чем у паттернов, при этом концентрация и шанс встрять в бестолковую дискуссию — выше в разы в силу меньшего объема и большей вариативности текста. Достаточно сказать, что даже вопрос их количества имеет как минимум 3 варианта ответа, каждый из которых по сути верный но по факту может быть зачтен как «что это за ересь?». Общий смысл - простые правила для ограничения  показателей копипастности, багоносности и макаронности кода, на практике как ни странно дают обратный результат при их буквальном(шаблонном) усваивании. Если чуть вкратце но подробней —

**Наследование** — главное оружие против НЕ СУХОЙ(NOT DRY) копипасты, 

**Инкапсуляция** — способ обеспечить защиту от дурака там где это важно (все равно бесполезно, ибо чаще всего перед виновником применения инкапсуляции объект применения беззащитен), 

**Полиморфизм** *одной цитатой* - «мне вот такой же точно, но с перламутровыми пуговицами», 

**Абстракция** — единственный логично названный и действительно ключевой, хоть и тоже предельно очевидный принцип, за что его постоянно исключают из принципиальных рядов в ходе различных холиваров. Адекватность, логичность и простота изложения вообще являются первыми критериями жесткой отбраковки тем для интервью — а потом мы удивляемся идентичности уровня качества кода в большинстве проектов и дна Марианской впадины. Для того чтобы писать прозрачный, легкий, очевидный интуитивно понятный и осознанный код нужно чтобы голова и её содержимое было в близком состоянии — а фильтрация сотрудников настроена на фильтрацию этих качеств и поощрение противоположных. Вот и получаем то, что заслужили.

**Монады** — больше характерно для back-end функциональщины (Haskell, Elixir, Scala, Swift + perversions, etc) но со временем и технологиями (Elm, React 16.8+, TypeScript + perversions, etc) вошло и в список front-end ленивых вариантов вопросов. По форме — ключевая концепция одной матан теории. В своем контексте действительно интересная и в пределах теории полезная для понимания идея. Но это в матане, там с этим строго - а вот в программировании это несколько иное, хоть и внешне похожее явление, бесстыдно расширяющее возможности функциональщины. По смыслу — способ совершенно не функционально но с умным видом писать функционалку, «и явил Б-г мне чудо — везде суббота, а вокруг меня - четверг». Уровень вышеупомянутого «непонятно о понятном или сложно о простом» зашкаливает. Если идею взяли из матана — это не повод описывать её для программирования совершенно не меняя стиль и логику описания — тут другая ситуация и цели другие. Если бы не карго-культ вокруг Монады она была бы вполне симпатичной, но, как часто бывает, все убили постоянные псевдосапиенсные холивары вокруг предмета, поражающего своей обманчивой заумностью в свете поверхностного восприятия а по сути являющегося довольно очевидно необходимой концепцией в логике принятых для её среды жестких условий, Что обеспечивает наличие абсолютно различных вариантов её реализации в подавляющем большинстве функциональных и притворяющихся таковыми языков программирования.

**Каррирование** — из той же оперы что и монады, но «в отличии от» элементарно реализуется в JS ES5+ из-за чего шанс натолкнуться выше чем у монад. В целом изредка полезная возможность из одной функции с «много» аргументов сделать много функций с «хотя-бы один» аргументами и дальше с ними играться, нюанс JS реализации — вариант по дефолту с «много» аргументов никуда от нас не пропадает, что и делает в условиях JS этот механизм изредка полезным. Конечно, если забыть про реакт и его с недавних пор неформально обязательное для компонентных и прочих пропсов деструктурирующее присваивание, которое фактом своего наличия исключает возможность каррирования — аргумент всегда один с множеством ключей, у каждого из этих ключей может быть значение,  имя всей этой знакомой конструкции неожиданно... Объект.

**Объекты в JS** — самый вариативный и с немалой долей вероятности западлистый вопрос. Можно рассказать о том, что «в ООП все есмь объект а в JS есмь ООП»(ну или его имитация), можно на тему «вообще-то в JS так называют то, что по нормальному определяется как ассоциативный массив, который в JS определяется через иллюзорно знакомое но такое чужое Map, а то что назвали массивом в JS вообще кастрировано», еще можно вспомнить что в глобальном скопе есть класс Object, спроектированный по схеме конструктор, у него куча полезных функций — можно новый экземпляр класса объект с типом данных объект создать, реализовав тем самым пример концепции тавтологии) Еще заморозить можно. Для иммутабельности. И много чего другого, крайне полезного, что можно легко вспомнить с помошью глобального обьекта консоль и её метода лог в браузерной консольной же строке). Также этот глобальный класс (объект? функция?) примечателен тем что чаще всего становится поводом для вызова его же метода prototype.

**Прототипы** — священная корова интервью по JS — главный виновник возникновения вопросов по ООП в интервью и хрестоматийная демонстрация наследования и полиморфизма в одном флаконе. В целом действительно удобный и простой механизм, его легко понять и применять ровно до того момента как заглянешь в документацию — то что там описано имеет мало общего с удобством, полезностью и ничего общего с простотой.  А ведь на самом деле была полезная штука. Могут еще попросить рассказать концепцию ПОП (как ООП только с прототипами, делегированием и другими интересными идеями) — редкий случай когда содержимое концепции абсолютно логичное и полностью релевантное названию. 

**S.O.L.I.D** - квинтессенция псевдоразумной и маловразумительно полезной, а при вникании - нелепо очевидной концепции. Здесь прекрасно все - и то, что это аббревиатура и вопрос содержит обязательное требование расшифровки, и то какая это аббревиатура - ТРАНСЦЕНДЕНТНАЯ ЫРРАЦИОНАЛЬНЫЙ ПЕТРОВ И ДЕСТАБИЛИЗИРОВАНИЕ ОНКОЛАКТИДНОГО (а ещё) РЕФРАКТОР - вот примерно как-то так оно выглядит с первого, второго да и всех последующих разолов - нелогично расположенные разсогласованные по всем параметрам языка живых людей группы терминов без какой либо попытки организации, в центре фамилия с именем - и все это ради подходящего по смыслу слова в результате - это ли не верх карго культа иммитации наличия разума в нашем Б-гспасаемом IT комьюнити? Неудобно, нелогично, сложно к восприятию, антиинтуитивно но в итоге слово все вместе какое класное - ЖОСТКО - тут у меня дежа вю относительно предположений по хейту Синглтона - не хвататет расшрения этого набора анальных ограничений для вчерашних манкикодеров - PENETRATION, и как-то потом так все подкрутить чтобы на русском смысл сохранить - ЖОСТКО ВЫЕБАЛИ. Тогда я думаю популяррность этой темы возрастет по экспоненте - хотя куда уж, и так... А в целом довольно очевидный набор правил, смысл переть можно чуть короче - "Не пиши плохой код, как ты до этого привык" - суммарно с большой популярностью этого вопроса на интервью я теперь понимаю откуда растут ноги нынешних проблем отрасли - 

## Практические непрактичные задачи

**Написать кастомный редюсер** - *ну это как редюсер в window.Array стандартный только кастомный*

    Array.prototype.reduce = function reducer(){
        console.debug(`This is custom ${[].reduce.name}, LOL)`);
    };
    [].reduce();

**Написать функцию которая проверяет строку на палиндромность**

    -- Вы задаете вопросы по функционалке — я ей вопользуюсь
    isPalindrome w = w == reverse w; -- Но не всей, а конкретно Б-гподобным в таких вопросах Haskell
     -- Настолько же лаконично, красиво и прозрачно он может, кстати, в различные Math опперации. 

**Сделать ToDo List SFA(single file application)** *за 30 минут в этой большом текстовом поле на js и любом фреймворке. Или без него. Или без js… Нет, без этого окна нельзя, надо в нем.*

мне хватит 1 минуты и чтоб с js и работало — сложно писать бесполезный код когда нет такой привычки, сложно тратить столько времени на бесполезный код, когда помнишь его цену и цену ошибки в реальных боевых задачах. Так что по пунктам:

1) Открываем консоль браузера
2) Пишем или копипастим:

        const iframe = document.createElement('iframe');
        iframe.setAttribute("style", `width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1 `);
        iframe.setAttribute("loading", `lazy`);
        iframe.setAttribute("allowfullscreen", true);
        iframe.src = `https://codepen.io/oddvalue/embed/preview/dpBGpj?theme-id=dark&default-tab=result`; 
        document.body.scrollIntoView();
        document.body.appendChild(iframe);

3) Прессим Enter
4) PROFIT

И этот результат будет заведомо лучше среднего по палате. В нем можно будет создать задачи на ближайший день и отслеживать их выполнение — а ведь именно в этом ценность TODO листа, насколько я помню. И мне реально жаль тех, чей результат превзойдет этот. Я только что подарил вам 29 минут жизни, благодарить не обязательно)
